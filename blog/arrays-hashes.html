<!DOCTYPE html>
<head>
  <title>Blog Post #3</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="arrays-hashes.css">
</head>
<body>
  <main>
    <h1>Arrays and Hashes, Part 1</h1>
    <h2>Two powerful data structures in the Ruby programming language</h2>
    <h4>Sunday, February 14, 2016</h4>

    <section>
      <p>
        As we progress further into Ruby territory we learn about data structures and their uses.  The two most predominate ones are arrays and hashes.  I intend the following blog entry to serve as a brief introduction and explanation of each structure and how and when to use them.  These will be very important objects to understand and have in your knowledge bank as a Rubyist.
      </p>

      <p>
        First, we'll start out with arrays as these are probably the most common.  Arrays are data structures that hold a collection of information (i.e. strings, integers/floats, etc.) that can be recalled easily through referencing predefined indices.  These indices are always represented by integers and always start at '0.'  Now, this is a little tricky to get used to at first when just starting out as a programmer, but this a very common throughout the programming world, so the sooner you get used to it, the better.  If it helps, you can refer to the first value in an array as the "zeroth" value (then "first", "second", and so on.)
      </p>

      <p>
        Now, there are several different ways to create an array in Ruby (just as there are many different ways to do just about everything in Ruby!)  Here I'll be covering two, the first of which is the Array.new method:
      </p>

      <div>
      <blockquote>
      <pre>
        <code>
          new = Array.new
        </code>
      </pre>
      </blockquote>
      </div>

      <p>
        This setup is just like creating a new variable (you can assign whatever name you want) but instead of assigning a value you are creating a new array.  Now, it is important to note here that the "a" in "Array.new" is capitalized so that Ruby knows to create a new array.
      </p>

      <p>
        Secondly, we have the more direct way, the literal method:
      </p>

      <div>
      <blockquote>
      <pre>
        <code>
          new_array = []
        </code>
      </pre>
      </blockquote>
      </div>

      <p>
        For both of these methods it is important to note that you can create a new array and place values within them at the same time:
      </p>

      <div>
      <blockquote>
      <pre>
        <code>
          new_array = Array.new(3, "456")
          new_array = ["cat", 1, "Hello, world!", []]
        </code>
      </pre>
      </blockquote>
      </div>

      <p>
        Let it be known that in the first example, the parameters that "Array.new" is accepting are the initial number of indices and what to put in them.  Returning this array (in an irb session) would look like this:

      <div>
      <blockquote>
      <pre>
        <code>
          > new_array = Array.new(3, "456")
          => ["456", "456", "456"]
          > new_array
          => ["456", "456", "456"]
        </code>
      </pre>
      </blockquote>
      </div>

      <p>
        Notice that this places three instances of the string "456" in indices 0, 1, and 2.  If you want to place different values in each index, you can use the following syntax:
      </p>

      <div>
      <blockquote>
      <pre>
        <code>
          new_array[0] << "123"
        </code>
      </pre>
      </blockquote>
      </div>

      <p>
        This will place the string "123" into index 0 of "new_array."  Now, if you want to recall values from arrays, you would simply call the array this way:
      </p>

      <div>
      <blockquote>
      <pre>
        <code>
          new_array[0]
        </code>
      </pre>
      </blockquote>
      </div>

      <p>
        This will return the value from index 0 in the array "new_array."  (There are many methods of recalling, storing, and manipulating data from arrays, but I will save that for a more in-depth blog post at a later time.)
      </p>

      <p>
        Returning to our example of initializing our array with literal method, we have input the string "cat" in index 0, the value 1 in index 1, the string "Hello, world!" in index 2, and an empty array in index 3.  We can store a wide variety of data within an array as you can see.  For creating a new array, I personally like the literal method better as it seems to be a bit more straightforward but I highly recommend becoming familiar with both (and the other methods*) of creating new arrays as well.
      </p>

      <p>
        Now, for our second data structure of the day, let's look at hashes.  Hashes are very similar to arrays in their look and syntax.  However, the big difference here is how information is stored and recalled in a hash.  with arrays, are indices are already laid out for us and uniformly labelled; not too much to worry about there.  However, hashes operate on the same principles but here you can assign your index values!  In a hash, this is called a "key", which is then paired with a "value".  (Note:  hashes don't necessarily order their key/value pairs in any way but they do keep track of what sequence the key/value pairs are entered.  Also, you can have many similar values in a hash, but each key is unique and can only be used once.)  Let's look at the two main methods for creating and initializing hashes (first with "Hash.new" and then the literal method):
      </p>

      <div>
      <blockquote>
      <pre>
        <code>
          new_hash = Hash.new
          new_hash = {}
        </code>
      </pre>
      </blockquote>
      </div>

      <p>
        See, as I said, very similar to arrays in their syntax, but notice that hashes go in curly braces as opposed to square ones.  To a new hash and initialize with data, we also follow similar syntax but this is where things start to differ:
      </p>

      <div>
      <blockquote>
      <pre>
        <code>
          new_hash = Hash.new(0)
          new_hash = {"0" => "zero",
                      "1" => "one",
                      "2" => "two",
                      "3" => "three"}
        </code>
      </pre>
      </blockquote>
      </div>

      <p>
        Here, things can get a little confusing but I'll do my best to clear things up.  For the literal method, providing it with an argument will tell the hash to apply this value as a default for any unassigned hash keys.  I won't go too much into this as this will likely be an discussion in a later blog post.*  In the literal method below it, we see our key/value pair assignments.  In this example, the string "0" is assigned as the key for the assigned value "zero" using the "=>" operator.  Again, recalling information for a hash is very similar to arrays.  You can a recall values by entering the corresponding key into the hash:
      </p>

      <div>
      <blockquote>
      <pre>
        <code>
         new_hash[1]
        </code>
      </pre>
      </blockquote>
      </div>

      <p>
        Which will return the value "one" stored in key "1."
      </p>

      <p>
        I hope that this has been an informative and helpful introduction to arrays and hashes in Ruby.  I will be delving further into these topics including built-in methods and specifying default values and behaviors in future posts.  For now, if you have any questions or comments, please feel free to contact me.  I'm always looking to learn and help learn where and when I can.
      </p>
      </section>
    </main>
  </body>
  </html>